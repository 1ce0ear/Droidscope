
/*
Copyright (C) <2012> <Syracuse System Security (Sycure) Lab>
This is a plugin of DECAF. You can redistribute and modify it
under the terms of BSD license but it is made available
WITHOUT ANY WARRANTY. See the top-level COPYING file for more details.

For more information about DECAF and other softwares, see our
web site at:
http://sycurelab.ecs.syr.edu/

If you have any questions about DECAF,please post it on
http://code.google.com/p/decaf-platform/
*/
/**
* @author Abhishek Vasisht Bhaskar
* @date March 15, 2016
* Basic plugin which records function calls and their lengths using Droidscope.
*/

#include <sys/time.h>

#include "DECAF_main.h"
#include "DECAF_callback.h"
#include "DECAF_shared/vmi_callback.h"
#include "vmi_c_wrapper.h"
#include "DECAF_shared/dalvik_common.h"
#include "function_map.h"
#include "vmi.h"
#include "art_vmi.h"
#include <iostream>
#include <fstream>
#include <ctype.h>
#include <string.h>
#include <stdio.h>

#include <stack>          // std::stack
#include <string>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <sstream> 
#include <fstream>


#define SIZEOF_TYPE(struct_type) (sizeof(struct_type))
#define pgd_strip(_pgd) (_pgd & ~0xC0000FFF)


//Unsed but maybe used in future vars
static int __attribute__((unused)) monitoring = 1;
static uint32_t __attribute__((unused)) counter = 0;
static tmodinfo_t __attribute__((unused)) module_info;
//end

#define LOGW 0

#define DECAF_printf(...) monitor_printf(default_mon, __VA_ARGS__)
#define log_printf(...) fprintf(log_fd_jumps, __VA_ARGS__)

static plugin_interface_t hookapitests_interface;
//static DECAF_Handle modulebegin_handle = DECAF_NULL_HANDLE;
static DECAF_Handle processbegin_handle = DECAF_NULL_HANDLE;
static DECAF_Handle insn_begin_handle = DECAF_NULL_HANDLE;
static DECAF_Handle memwrite_handle = DECAF_NULL_HANDLE;
static DECAF_Handle module_load_handle = DECAF_NULL_HANDLE, block_begin_cb_handle = DECAF_NULL_HANDLE;
static unordered_set<target_ulong> oat_files_extracted;

/* Data structure to hold callstack data */
struct tiny {
	public:
	std::string function_name;
	uint32_t instructions;
	target_ulong lr;

	tiny(std::string name_) : function_name(name_)
	{
		instructions = 0;
		lr = 0;
	}
};
/* Shadow java callstack */
std::stack <tiny *> call_stack;

extern void DECAF_output_init(Monitor* mon);

static char targetname[512];
static char actualname[512];

static uint32_t fucntion_insns = 0;
static target_ulong current_lr = 0x00, base, targetpid = 0;
//static target_ulong current_pc = 0, current_cr3 = 0;
static target_ulong targetcr3 = 0;
static unordered_set<target_ulong> targetcr3s;
static bool inside_function = false;


static std::string log_name;
static FILE *log_fd_jumps;


static void insn_cb(DECAF_Callback_Params *param)
{
	CPUArchState *env = param->bb.env;

	target_ulong cur_pc = param->bb.cur_pc;
	target_ulong cr3 = DECAF_getPGD(env);
  
	if(DECAF_is_in_kernel(env) || !(targetcr3s.count(cr3))) {
		return;
	}

	/* Check if we're out of the function */
	if(inside_function)
	{
		if(cur_pc == call_stack.top()->lr) 
		{/* Dump data, mark outside_funciton - false */
			tiny* to_dump = call_stack.top();
			call_stack.pop();

			// make the instruction count inclusive
			if(!call_stack.empty())
			{
				tiny* next = call_stack.top();
				next->instructions += to_dump->instructions;
			}
      
			if(strstr(to_dump->function_name.c_str(), "framework") == NULL) {
				fprintf(log_fd_jumps, "java function - %s instructions : %d \n",  to_dump->function_name.c_str(), to_dump->instructions);
			}
			current_lr = fucntion_insns = 0;

      
		delete to_dump;
      
		if(call_stack.empty())
			inside_function = false;
		}
		else
		{
			++(call_stack.top()->instructions);
		}
	}
}

 /* Block begin callback
 * This is where we check if the PC corresponds to an offset in an OAT file, 
 * hence classifying it as a JAVA function
 *
 * Before that, for each OAT file that we get, we use APIs from libart-dscopeartdump.so to extract
 * offsets from the OAT file and store them
 */

static void block_begin_cb(DECAF_Callback_Params *param) 
{
	char modname[512];
	char functionname[512];
	
	CPUArchState *env = param->bb.env;

	target_ulong cur_pc = param->bb.cur_pc;
	target_ulong cr3 = DECAF_getPGD(env);
	  
	if(DECAF_is_in_kernel(env) || !(targetcr3s.count(cr3))) {
		return;
	}

	module *module = NULL;
	module = VMI_find_module_by_pc(cur_pc, cr3, &base);

	if(module != NULL && module->is_oat)
	{
		char art_method[1024];
		if(!oat_files_extracted.count(module->inode_number))
	    {
			extract_oat_file(env, base);
			oat_files_extracted.insert(module->inode_number);
	    }

	    if(art_vmi_method_at(module->inode_number, (cur_pc - base), art_method))
	    {
			current_lr = env->regs[14];
			inside_function = true;
			tiny *to_insert = new tiny(std::string(art_method) + " module - " + std::string(module->name));
			to_insert->lr = current_lr;

			call_stack.push(to_insert);
	    }
	}
	else if(module != NULL && (strstr(module->name, "libc") != NULL))
	{
		if(funcmap_get_name_c(cur_pc, DECAF_getPGD(env), modname, functionname) == 0)
		{
			//fprintf(log_fd_jumps, "[FUNCTION CALL] [Module:] %s [Function:] %s\n", modname, functionname);
			DECAF_printf("[FUNCTION CALL] [Module:] %s [Function:] %s\n", modname, functionname);

			if(strstr(functionname, "malloc") == 0)
			{
				DECAF_printf("top java level function: ");
				if(!call_stack.empty())
					DECAF_printf("%s\n", call_stack.top()->function_name.c_str());

				DECAF_printf("allocate memory size: %ld\n", env->regs[0]);
				
				// fprintf(log_fd_jumps, "top java level function: ");
				// if(!call_stack.empty())
				// 	fprintf(log_fd_jumps, "%s\n", call_stack.top()->function_name.c_str());

				// fprintf(log_fd_jumps, "allocate memory size: %ld\n", env->regs[0]);
			}
		}
	}
}

static void register_hooks()
{
	insn_begin_handle = DECAF_register_callback(DECAF_INSN_BEGIN_CB, insn_cb, NULL);
	block_begin_cb_handle = DECAF_register_callback(DECAF_BLOCK_BEGIN_CB, block_begin_cb, NULL);
}

static void createproc_callback(VMI_Callback_Params* params)
{
	if (targetpid == 0 && strlen(targetname) > 1 && strstr(params->cp.name, targetname) != 0) {
		targetpid = params->cp.pid;
		targetcr3 = params->cp.cr3;
		targetcr3s.insert(targetcr3);

		strncpy(actualname, params->cp.name, strlen(params->cp.name));
		actualname[511] = '\0';

		register_hooks();
		DECAF_printf("process found: pid=%08x, cr3=%08x, name = %s\n", targetpid, targetcr3, params->cp.name);
	}
}

static void do_hookapitests(Monitor* mon, const char* proc_name)
{
	if(strlen(proc_name) < 512) {
		DECAF_printf("try to hook process: %s\n", proc_name);
		strncpy(targetname, proc_name, strlen(proc_name));

		log_name = std::string("./") + targetname + "_jumps.log";
    
		log_fd_jumps = fopen(log_name.c_str(), "rw");
	}
	else
		return;

	targetname[511] = '\0';
}

static void do_clear_log(Monitor *mon, char *command)
{

}

static int hookapitests_init(void)
{
	//DECAF_output_init(NULL);
	targetname[0] = '\0';
  
	//register for process create and process remove events
	processbegin_handle = VMI_register_callback(VMI_CREATEPROC_CB, &createproc_callback, NULL);
  
	return (0);
}

static void hookapitests_cleanup(void)
{
	if (processbegin_handle != DECAF_NULL_HANDLE) 
	{
		VMI_unregister_callback(VMI_CREATEPROC_CB,
 		processbegin_handle);
		processbegin_handle = DECAF_NULL_HANDLE;
	}

	if (module_load_handle != DECAF_NULL_HANDLE) 
	{
		VMI_unregister_callback(VMI_LOADMODULE_CB, module_load_handle);
		module_load_handle = DECAF_NULL_HANDLE;
	}

	if(block_begin_cb_handle != DECAF_NULL_HANDLE)
	{
		DECAF_unregister_callback(DECAF_BLOCK_BEGIN_CB, block_begin_cb_handle);
	}

	if(insn_begin_handle != DECAF_NULL_HANDLE)
	{
		DECAF_unregister_callback(DECAF_INSN_BEGIN_CB, insn_begin_handle);
	}  

	if(memwrite_handle != DECAF_NULL_HANDLE)
	{
		DECAF_unregister_callback(DECAF_MEM_WRITE_CB, memwrite_handle);
	}

  //fclose(log_fd_jumps);
}

static mon_cmd_t hookapitests_term_cmds[] = {
	#include "plugin_cmds.h"
	{ NULL, NULL, }, 
};

extern "C" plugin_interface_t* init_plugin(void) {
	hookapitests_interface.mon_cmds = hookapitests_term_cmds;
	hookapitests_interface.plugin_cleanup = &hookapitests_cleanup;
	//initialize the plugin
	hookapitests_init();
	return (&hookapitests_interface);
}