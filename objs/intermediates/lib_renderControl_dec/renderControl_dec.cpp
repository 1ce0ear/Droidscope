// Generated Code - DO NOT EDIT !!
// generated by 'emugen'


#include <string.h>
#include "renderControl_opcodes.h"

#include "renderControl_dec.h"


#include "ProtocolUtils.h"

#include <stdio.h>

typedef unsigned int tsize_t; // Target "size_t", which is 32-bit for now. It may or may not be the same as host's size_t when emugen is compiled.

#ifdef DEBUG_PRINTOUT
#  define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#else
#  define DEBUG(...)  ((void)0)
#endif

#ifdef CHECK_GLERROR
#  define SET_LASTCALL(name)  sprintf(lastCall, #name)
#else
#  define SET_LASTCALL(name)  ((void)0)
#endif

using namespace emugl;

size_t renderControl_decoder_context_t::decode(void *buf, size_t len, IOStream *stream)
{
                           
	size_t pos = 0;
	if (len < 8) return pos; 
	unsigned char *ptr = (unsigned char *)buf;
	bool unknownOpcode = false;  
#ifdef CHECK_GL_ERROR 
	char lastCall[256] = {0}; 
#endif 
	while ((len - pos >= 8) && !unknownOpcode) {   
		uint32_t opcode = *(uint32_t *)ptr;   
		size_t packetLen = *(uint32_t *)(ptr + 4);
		if (len - pos < packetLen)  return pos; 
		switch(opcode) {
		case OP_rcGetRendererVersion: {
			size_t totalTmpSize = sizeof(GLint);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("renderControl(%p): rcGetRendererVersion()\n", stream);
			*(GLint *)(&tmpBuf[0]) = 			this->rcGetRendererVersion();
			stream->flush();
			SET_LASTCALL("rcGetRendererVersion");
			break;
		}
		case OP_rcGetEGLVersion: {
			uint32_t size_major __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_minor __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			size_t totalTmpSize = size_major;
			totalTmpSize += size_minor;
			totalTmpSize += sizeof(EGLint);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_major(&tmpBuf[0], size_major);
			OutputBuffer outptr_minor(&tmpBuf[0 + size_major], size_minor);
			DEBUG("renderControl(%p): rcGetEGLVersion(%p(%u) %p(%u) )\n", stream,(EGLint*)(outptr_major.get()), size_major, (EGLint*)(outptr_minor.get()), size_minor);
			*(EGLint *)(&tmpBuf[0 + size_major + size_minor]) = 			this->rcGetEGLVersion((EGLint*)(outptr_major.get()), (EGLint*)(outptr_minor.get()));
			outptr_major.flush();
			outptr_minor.flush();
			stream->flush();
			SET_LASTCALL("rcGetEGLVersion");
			break;
		}
		case OP_rcQueryEGLString: {
			EGLenum var_name = Unpack<EGLenum,uint32_t>(ptr + 8);
			uint32_t size_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			EGLint var_bufferSize = Unpack<EGLint,uint32_t>(ptr + 8 + 4 + 4);
			size_t totalTmpSize = size_buffer;
			totalTmpSize += sizeof(EGLint);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_buffer(&tmpBuf[0], size_buffer);
			DEBUG("renderControl(%p): rcQueryEGLString(0x%08x %p(%u) 0x%08x )\n", stream,var_name, (void*)(outptr_buffer.get()), size_buffer, var_bufferSize);
			*(EGLint *)(&tmpBuf[0 + size_buffer]) = 			this->rcQueryEGLString(var_name, (void*)(outptr_buffer.get()), var_bufferSize);
			outptr_buffer.flush();
			stream->flush();
			SET_LASTCALL("rcQueryEGLString");
			break;
		}
		case OP_rcGetGLString: {
			EGLenum var_name = Unpack<EGLenum,uint32_t>(ptr + 8);
			uint32_t size_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			EGLint var_bufferSize = Unpack<EGLint,uint32_t>(ptr + 8 + 4 + 4);
			size_t totalTmpSize = size_buffer;
			totalTmpSize += sizeof(EGLint);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_buffer(&tmpBuf[0], size_buffer);
			DEBUG("renderControl(%p): rcGetGLString(0x%08x %p(%u) 0x%08x )\n", stream,var_name, (void*)(outptr_buffer.get()), size_buffer, var_bufferSize);
			*(EGLint *)(&tmpBuf[0 + size_buffer]) = 			this->rcGetGLString(var_name, (void*)(outptr_buffer.get()), var_bufferSize);
			outptr_buffer.flush();
			stream->flush();
			SET_LASTCALL("rcGetGLString");
			break;
		}
		case OP_rcGetNumConfigs: {
			uint32_t size_numAttribs __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			size_t totalTmpSize = size_numAttribs;
			totalTmpSize += sizeof(EGLint);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_numAttribs(&tmpBuf[0], size_numAttribs);
			DEBUG("renderControl(%p): rcGetNumConfigs(%p(%u) )\n", stream,(uint32_t*)(outptr_numAttribs.get()), size_numAttribs);
			*(EGLint *)(&tmpBuf[0 + size_numAttribs]) = 			this->rcGetNumConfigs((uint32_t*)(outptr_numAttribs.get()));
			outptr_numAttribs.flush();
			stream->flush();
			SET_LASTCALL("rcGetNumConfigs");
			break;
		}
		case OP_rcGetConfigs: {
			uint32_t var_bufSize = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			size_t totalTmpSize = size_buffer;
			totalTmpSize += sizeof(EGLint);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_buffer(&tmpBuf[0], size_buffer);
			DEBUG("renderControl(%p): rcGetConfigs(0x%08x %p(%u) )\n", stream,var_bufSize, (GLuint*)(outptr_buffer.get()), size_buffer);
			*(EGLint *)(&tmpBuf[0 + size_buffer]) = 			this->rcGetConfigs(var_bufSize, (GLuint*)(outptr_buffer.get()));
			outptr_buffer.flush();
			stream->flush();
			SET_LASTCALL("rcGetConfigs");
			break;
		}
		case OP_rcChooseConfig: {
			uint32_t size_attribs __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_attribs(ptr + 8 + 4, size_attribs);
			uint32_t var_attribs_size = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_attribs);
			uint32_t size_configs __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_attribs + 4);
			uint32_t var_configs_size = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_attribs + 4 + 4);
			size_t totalTmpSize = size_configs;
			totalTmpSize += sizeof(EGLint);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_configs(&tmpBuf[0], size_configs);
			DEBUG("renderControl(%p): rcChooseConfig(%p(%u) 0x%08x %p(%u) 0x%08x )\n", stream,(EGLint*)(inptr_attribs.get()), size_attribs, var_attribs_size, (uint32_t*)(outptr_configs.get()), size_configs, var_configs_size);
			*(EGLint *)(&tmpBuf[0 + size_configs]) = 			this->rcChooseConfig((EGLint*)(inptr_attribs.get()), var_attribs_size, size_configs == 0 ? NULL : (uint32_t*)(outptr_configs.get()), var_configs_size);
			outptr_configs.flush();
			stream->flush();
			SET_LASTCALL("rcChooseConfig");
			break;
		}
		case OP_rcGetFBParam: {
			EGLint var_param = Unpack<EGLint,uint32_t>(ptr + 8);
			size_t totalTmpSize = sizeof(EGLint);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("renderControl(%p): rcGetFBParam(0x%08x )\n", stream,var_param);
			*(EGLint *)(&tmpBuf[0]) = 			this->rcGetFBParam(var_param);
			stream->flush();
			SET_LASTCALL("rcGetFBParam");
			break;
		}
		case OP_rcCreateContext: {
			uint32_t var_config = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_share = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			uint32_t var_glVersion = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			size_t totalTmpSize = sizeof(uint32_t);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("renderControl(%p): rcCreateContext(0x%08x 0x%08x 0x%08x )\n", stream,var_config, var_share, var_glVersion);
			*(uint32_t *)(&tmpBuf[0]) = 			this->rcCreateContext(var_config, var_share, var_glVersion);
			stream->flush();
			SET_LASTCALL("rcCreateContext");
			break;
		}
		case OP_rcDestroyContext: {
			uint32_t var_context = Unpack<uint32_t,uint32_t>(ptr + 8);
			DEBUG("renderControl(%p): rcDestroyContext(0x%08x )\n", stream,var_context);
			this->rcDestroyContext(var_context);
			SET_LASTCALL("rcDestroyContext");
			break;
		}
		case OP_rcCreateWindowSurface: {
			uint32_t var_config = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_width = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			uint32_t var_height = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			size_t totalTmpSize = sizeof(uint32_t);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("renderControl(%p): rcCreateWindowSurface(0x%08x 0x%08x 0x%08x )\n", stream,var_config, var_width, var_height);
			*(uint32_t *)(&tmpBuf[0]) = 			this->rcCreateWindowSurface(var_config, var_width, var_height);
			stream->flush();
			SET_LASTCALL("rcCreateWindowSurface");
			break;
		}
		case OP_rcDestroyWindowSurface: {
			uint32_t var_windowSurface = Unpack<uint32_t,uint32_t>(ptr + 8);
			DEBUG("renderControl(%p): rcDestroyWindowSurface(0x%08x )\n", stream,var_windowSurface);
			this->rcDestroyWindowSurface(var_windowSurface);
			SET_LASTCALL("rcDestroyWindowSurface");
			break;
		}
		case OP_rcCreateColorBuffer: {
			uint32_t var_width = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_height = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			GLenum var_internalFormat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			size_t totalTmpSize = sizeof(uint32_t);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("renderControl(%p): rcCreateColorBuffer(0x%08x 0x%08x 0x%08x )\n", stream,var_width, var_height, var_internalFormat);
			*(uint32_t *)(&tmpBuf[0]) = 			this->rcCreateColorBuffer(var_width, var_height, var_internalFormat);
			stream->flush();
			SET_LASTCALL("rcCreateColorBuffer");
			break;
		}
		case OP_rcOpenColorBuffer: {
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			DEBUG("renderControl(%p): rcOpenColorBuffer(0x%08x )\n", stream,var_colorbuffer);
			this->rcOpenColorBuffer(var_colorbuffer);
			SET_LASTCALL("rcOpenColorBuffer");
			break;
		}
		case OP_rcCloseColorBuffer: {
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			DEBUG("renderControl(%p): rcCloseColorBuffer(0x%08x )\n", stream,var_colorbuffer);
			this->rcCloseColorBuffer(var_colorbuffer);
			SET_LASTCALL("rcCloseColorBuffer");
			break;
		}
		case OP_rcSetWindowColorBuffer: {
			uint32_t var_windowSurface = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			DEBUG("renderControl(%p): rcSetWindowColorBuffer(0x%08x 0x%08x )\n", stream,var_windowSurface, var_colorBuffer);
			this->rcSetWindowColorBuffer(var_windowSurface, var_colorBuffer);
			SET_LASTCALL("rcSetWindowColorBuffer");
			break;
		}
		case OP_rcFlushWindowColorBuffer: {
			uint32_t var_windowSurface = Unpack<uint32_t,uint32_t>(ptr + 8);
			size_t totalTmpSize = sizeof(int);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("renderControl(%p): rcFlushWindowColorBuffer(0x%08x )\n", stream,var_windowSurface);
			*(int *)(&tmpBuf[0]) = 			this->rcFlushWindowColorBuffer(var_windowSurface);
			stream->flush();
			SET_LASTCALL("rcFlushWindowColorBuffer");
			break;
		}
		case OP_rcMakeCurrent: {
			uint32_t var_context = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_drawSurf = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			uint32_t var_readSurf = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			size_t totalTmpSize = sizeof(EGLint);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("renderControl(%p): rcMakeCurrent(0x%08x 0x%08x 0x%08x )\n", stream,var_context, var_drawSurf, var_readSurf);
			*(EGLint *)(&tmpBuf[0]) = 			this->rcMakeCurrent(var_context, var_drawSurf, var_readSurf);
			stream->flush();
			SET_LASTCALL("rcMakeCurrent");
			break;
		}
		case OP_rcFBPost: {
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			DEBUG("renderControl(%p): rcFBPost(0x%08x )\n", stream,var_colorBuffer);
			this->rcFBPost(var_colorBuffer);
			SET_LASTCALL("rcFBPost");
			break;
		}
		case OP_rcFBSetSwapInterval: {
			EGLint var_interval = Unpack<EGLint,uint32_t>(ptr + 8);
			DEBUG("renderControl(%p): rcFBSetSwapInterval(0x%08x )\n", stream,var_interval);
			this->rcFBSetSwapInterval(var_interval);
			SET_LASTCALL("rcFBSetSwapInterval");
			break;
		}
		case OP_rcBindTexture: {
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			DEBUG("renderControl(%p): rcBindTexture(0x%08x )\n", stream,var_colorBuffer);
			this->rcBindTexture(var_colorBuffer);
			SET_LASTCALL("rcBindTexture");
			break;
		}
		case OP_rcBindRenderbuffer: {
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			DEBUG("renderControl(%p): rcBindRenderbuffer(0x%08x )\n", stream,var_colorBuffer);
			this->rcBindRenderbuffer(var_colorBuffer);
			SET_LASTCALL("rcBindRenderbuffer");
			break;
		}
		case OP_rcColorBufferCacheFlush: {
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			EGLint var_postCount = Unpack<EGLint,uint32_t>(ptr + 8 + 4);
			int var_forRead = Unpack<int,uint32_t>(ptr + 8 + 4 + 4);
			size_t totalTmpSize = sizeof(EGLint);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("renderControl(%p): rcColorBufferCacheFlush(0x%08x 0x%08x %d )\n", stream,var_colorbuffer, var_postCount, var_forRead);
			*(EGLint *)(&tmpBuf[0]) = 			this->rcColorBufferCacheFlush(var_colorbuffer, var_postCount, var_forRead);
			stream->flush();
			SET_LASTCALL("rcColorBufferCacheFlush");
			break;
		}
		case OP_rcReadColorBuffer: {
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_width = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_height = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			size_t totalTmpSize = size_pixels;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_pixels(&tmpBuf[0], size_pixels);
			DEBUG("renderControl(%p): rcReadColorBuffer(0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x %p(%u) )\n", stream,var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, (void*)(outptr_pixels.get()), size_pixels);
			this->rcReadColorBuffer(var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, (void*)(outptr_pixels.get()));
			outptr_pixels.flush();
			stream->flush();
			SET_LASTCALL("rcReadColorBuffer");
			break;
		}
		case OP_rcUpdateColorBuffer: {
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_width = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_height = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_pixels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_pixels);
			size_t totalTmpSize = sizeof(int);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("renderControl(%p): rcUpdateColorBuffer(0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x %p(%u) )\n", stream,var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, (void*)(inptr_pixels.get()), size_pixels);
			*(int *)(&tmpBuf[0]) = 			this->rcUpdateColorBuffer(var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, (void*)(inptr_pixels.get()));
			stream->flush();
			SET_LASTCALL("rcUpdateColorBuffer");
			break;
		}
		case OP_rcOpenColorBuffer2: {
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			size_t totalTmpSize = sizeof(int);
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("renderControl(%p): rcOpenColorBuffer2(0x%08x )\n", stream,var_colorbuffer);
			*(int *)(&tmpBuf[0]) = 			this->rcOpenColorBuffer2(var_colorbuffer);
			stream->flush();
			SET_LASTCALL("rcOpenColorBuffer2");
			break;
		}
			default:
				unknownOpcode = true;
		} //switch
		if (!unknownOpcode) {
			pos += packetLen;
			ptr += packetLen;
		}
	} // while
	return pos;
}
